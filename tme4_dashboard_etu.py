# -*- coding: utf-8 -*-
"""TME4-dashboard-etu.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DiGDsBbaTKkMH6YvJUFnkuGZRB4Q9P-H

# Dashboard

The objective is to design dashboard using the Dash library. This is designed to display data and visualisations in a web browser page. This is extremely useful if you want to summarise and share your data science results and analyses with other people.

*   You can look at the following tutorial as a reference: [tutorial](https://dash.plotly.com/tutorial)

First, let's load the necessary libraries and load some data:
"""

from dash import Dash, html, dash_table, dcc, Input, Output
import plotly.express as px
import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA

df = pd.read_csv('customers.csv')
print(df.head())

"""## 1/ Creating a dash app

The Dash ```app``` is a function to create the window which runs in a navigator. This allows you to visualise and share the data and potential analyses of these data. This is very useful for showing your results to collaborators (or clients). First, create the "app" with the following function:
- ```app = Dash(__name__)```

"""

app = Dash(__name__)

"""Now, we need to create the visual layout of the page. This can be done using syntax which is coherent with html code. For example, to create an html "Division" (a section in the page), you can use the following syntax:
- ```app.layout = html.Div([ ... ])```
Inside the Div object, we can put different objects/components. For example, we can add a title:
- ```html.H1("My title")```
To put other components, we simply put a list: ```app.layout = html.Div([comp_a,comp_b,comp_c, ...])```

Create the ```app.layout``` now, with a title in it:
"""

# STUDENT
title = html.H1("My title")
app.layout = html.Div([title])

"""Finally, to run the app, we use the code in the following cell. This starts a lightweight Flask server in the background, serving your app at http://127.0.0.1:8050/

Flask is a framework to run the page, managing HTTP requests and responses. Run the following code to run the app now:
"""

#  Run app
if __name__ == '__main__':
    app.run(debug=True)

"""## 2/ First components of layout

Now, let's include some more components in our Division. Here are a few ones:

- ```dcc.Input(...)```: a text box to put some input text. https://dash.plotly.com/dash-core-components/input
- ```dcc.Slider(...)```: a slider to change a scalar value. https://dash.plotly.com/dash-core-components/slider
- ```html.Br()```: gives a line break (go to next line) in html. https://dash.plotly.com/dash-html-components/br

Implement some of these now in a new Dash app, and run the app:
"""

# STUDENT
dcc.input = dcc.Input(id="my-input", value="world", type="text")
dcc.Slider(id="my-slider", min=0, max=10, step=1, value=5)
html.Br()

"""## 3/ Visualising data

The core task of the Dash app is visualisation (of data, for us). We can do this by adding more components to our html Division. This can be done by adding the object ```dash_table.DataTable``` to the list of components in the html Division. It is first necessary to convert our pandas data frame to a ```dash_table.DataTable```. To do this, use:
- ```dash_table.DataTable(data=df.to_dict('records'),columns=[{"name": i, "id": i} for i in df.columns],page_size=10)```
We need to do this because the html page can only manage a list of dictionaries (which are JSON compatible).

Next, we can draw a graph in the webpage. To do this, we use:
- ```dcc.Graph(figure=px.histogram(df, x='category'))```, where you must choose the ```category```
'category' corresponds to the name of the column over which we want to carry out the histogram. Let us choose the 'Fresh' column. Create a new app and add the dash ```DataTable``` to the list of components, followed by the ```dcc.Graph```, and finally, run the app.
"""

# STUDENT
dash_table.DataTable(data=df.to_dict('records'),columns=[{"name": i, "id": i} for i in df.columns],page_size=10)
dcc.Graph(figure=px.histogram(df, x='Fresh'))

"""## 4/ Callbacks

Callbacks refer to functions that are triggered when the user presses a button or clicks a mouse in the interactive app window. It is obviously extremely useful to have interactive displays of data and analyses. The callback function updates some **output** when some **input** changes. The syntax of callbacks is as follows:

```
@app.callback( Output('output-id', 'property'), Input('input-id', 'property'))
def my_callback_function(value):
    return my_result
```

- ```'output-id','property'```: the identifier of the object which is updated and the property which is updated. The ```property``` belongs to a Dash component. You have to find out what properties each component has - or, more likely, copy a code example which shows how to use this property
- ```'input-id', 'property'```: the identifier of the object whose change triggers the callback, and the property which is changed.

As a first simple example, create an app with the following setup (inside ```html.Div(...)``` as before):

- ```dcc.Input(id="my-input", value="world", type="text")```
- ```html.Div(id="my_output")```

After this, using the callback syntax above, add a callback function called ```update_output``` which takes as input ```value``` and returns "Hello 'value'". You can do this with ```return f"Hello {value}!"```

Finally, run the app as before.
"""

# STUDENT
dcc.Input(id="my-input", value="world", type="text")
html.Div(id="my_output")

"""### 4.1/ A more complicated callback

Now, lets create a more sophisticated callback. In this example, we are going to display a sine wave, and control the frequency of the sine wave with a ```dcc.Slider``` component, which you must put in the ```html.Div()``` component as above. This slider can be defined with the following syntax:
- ```dcc.Slider(id="your_slider_id",min=min_freq, max=max_freq, step=1, value=init_freq,marks={i: str(i) for i in range(min_freq, max_freq)})```
The ```marks={i: str(i) for i in range(min_period, max_period)}``` part defines the granularity of the slider.

After this, in the ```html.Div()```, you must also add a ```dcc.Graph(id=...)``` component, setting an id which you wish.

Concerning the callback, you should use the appropriate id's for the input, and well as the following properties: ```figure``` (for the output) and ```value``` (for the input). In the actual callback function, you must create the $x$ values which show a full period of a sine wave, and the y values which are given by $y=sin(freq*x)$. ```freq``` is the input of the callback function. To plot the sine wave, you can use the following code:
- ```fig = px.line(x=...,y=...)```: https://plotly.com/python-api-reference/generated/plotly.express.line

Finally, to update the figure, you can use:
- ```fig.update_layout```
To further enhance the visualisation, put the new frequency in the title of the figure: ```fig.update_layout(title=...)```.
"""

# STUDENT

# Define the frequency variables
min_freq = 1
max_freq = 10
init_freq = 1

dcc.Slider(id="your_slider_id",min=min_freq, max=max_freq, step=1, value=init_freq,marks={i: str(i) for i in range(min_freq, max_freq+1)})
dcc.Graph(id="your_graph_id")

# Define x and y for the sine wave
freq = init_freq  # Use the initial frequency
x = np.linspace(0, 2 * np.pi, 100)
y = np.sin(freq * x)

fig=px.line(x=x,y=y)
fig.update_layout(title=f"Frequency: {freq}")

"""## Summary:

### Q&A
* **Explain the error in the selected code:** The error encountered was an `ObsoleteAttributeException` when trying to run the Dash app using `app.run_server(debug=True)`. This exception indicates that the `run_server` method is obsolete and has been replaced by `app.run`.
* **Fix it if possible, and incorporate the changes into the existing code:** The error was fixed by replacing `app.run_server(debug=True)` with `app.run(debug=True)`. This corrected line was incorporated into the final code block which contains the complete Dash application.

### Data Analysis Key Findings
* Numerical columns were successfully identified and scaled using `StandardScaler`.
* PCA was applied to reduce the dimensionality of the scaled data to 2 components, stored in the `X_reduced` variable.
* The PCA-reduced data was successfully converted into a pandas DataFrame `df_reduced` with columns "PC1" and "PC2".
* A static scatter plot for the PCA-reduced data was generated using `plotly.express`, stored in `fig_pca`.
* A Dash app layout was created with two sections: one for an interactive scatter plot with dropdowns for selecting axes, and another for the static PCA plot.
* A callback function was successfully implemented to update the interactive scatter plot based on the dropdown selections.
* The Dash app was successfully run using `app.run(debug=True)`.

### Insights or Next Steps
* The dashboard successfully visualizes both the original data with interactive exploration and the PCA-reduced data.
* Consider adding more interactive features to the PCA plot, such as hover information or coloring points based on a categorical variable.
"""

# This cell is no longer needed as fig_pca is now created in the layout cell.
# Keeping it for now but it can be removed later if desired.
# fig_pca = px.scatter(df_reduced)

# This cell is no longer needed as the callback is now included in the layout cell.
# @app.callback(
#     Output('interactive-scatter-plot', 'figure'),
#     Input('x-axis-dropdown', 'value'),
#     Input('y-axis-dropdown', 'value')
# )
# def update_scatter_plot(selected_xaxis_column, selected_yaxis_column):
#     fig = px.scatter(df, x=selected_xaxis_column, y=selected_yaxis_column,
#                      title=f'Scatter Plot of {selected_xaxis_column} vs {selected_yaxis_column}')
#     return fig

if __name__ == '__main__':
    app.run(debug=True)

# Define the numeric columns from the DataFrame
numeric_cols = df.select_dtypes(include=np.number).columns

# Create the Dash app instance
app = Dash(__name__)

# Define the layout
app.layout = html.Div([
    html.H1("Customer Data Visualization"),
    html.Label("Select a column for the histogram:"),
    dcc.Dropdown(
        id='column-dropdown',
        options=[{'label': col, 'value': col} for col in numeric_cols],
        value=numeric_cols[0],  # Set an initial value
        clearable=False
    ),
    dcc.Graph(id='histogram-graph')
])

# Define the callback function to update the histogram
@app.callback(
    Output('histogram-graph', 'figure'),
    Input('column-dropdown', 'value')
)
def update_histogram(selected_column):
    fig = px.histogram(df, x=selected_column, title=f'Distribution of {selected_column}')
    return fig

# Run the app
if __name__ == '__main__':
    app.run(debug=True)

app = Dash(__name__)

app.layout = html.Div([
    html.H1("Interactive Sine Wave"),
    dcc.Slider(id="freq-slider", min=min_freq, max=max_freq, step=1, value=init_freq,
               marks={i: str(i) for i in range(min_freq, max_freq + 1)}),
    dcc.Graph(id="sine-wave-graph")
])


@app.callback(
    Output("sine-wave-graph", "figure"),
    Input("freq-slider", "value")
)
def update_graph(freq):
    x = np.linspace(0, 2 * np.pi, 100)
    y = np.sin(freq * x)
    fig = px.line(x=x, y=y)
    fig.update_layout(title=f"Frequency: {freq}")
    return fig

if __name__ == '__main__':
    app.run(debug=True)

"""## 5/ Dynamic visualisation of data with plotly

Now, we are going to visualise data in a dynamic manner, by creating a histogram of a column in the "customers.csv" data. Furthermore, we will allow the user to choose the column to visualise, using a callback. For this, we will use the following component:
- ```dcc.Dropdown(id=...,options=[{"label": c, "value": c} for c in numeric_cols], value=..., clearable=False)```: https://dash.plotly.com/dash-core-components/dropdown. The parameter which you will change in the callback is ```value```
- ```dcc.Graph(...)``` (similar to above)

To update the graph in the callback, use the following lines:
- ```fig = px.histogram(...)```
- ```fig.update_layout(...)```
"""

# STUDENT



"""## 5.1 Dynamic visualisation of scatter plots and static PCA

Finally, let us do some really sophisticated data analysis. In the main Division, we want two sub-windows which contain
- Left window: an **interactive** scatter plot where we can choose the two columns to visualise in the scatter plot
- Right window: a **static** scatter plot of the data reduced to 2 dimensions with PCA
You will put these in two sub-Divisions of the main Division.

For this, you can put two Divisions one after the other in the main Division (the first containing the scatter plot and the second containing the PCA). In the main Divison, use the following options: ```style={"display": "flex"}```. In the sub-divisions, use these options: ```style={"flex": "1"}```. ```"flex": 1``` means that the window takes up as much space as it is allowed. ```"display": "flex"``` means that the sub-Divisions will get stacked horizontally (better for visualisation.

For the dropdowns, you must create two separate ones, to put into the first sub-division. A callback can take several input arguments, as:
```
@app.callback(
    Output("output-id", "property"),
    Input("val1", "property"),
    Input("val1", "property")
)
def update_scatter(val1, val2):
    return ...
```

You should carry out the PCA dimension reduction **before** defining the Dash app (do not do it each time you call the callback). Before carrying out the PCA, scale the data using ```StandardScaler().```. You can acces the numerical data in df with ```df.values```. Plot the PCA-reduced data once at the beginning of the code with:
- ```df_reduced = pd.DataFrame(X_reduced, columns=["PC1", "PC2"])```
- ```fig_pca = px.scatter(df_reduced)```
"""

#STUDENT





"""# Task
Explain the error in the selected code, fix it if possible, and incorporate the changes into the existing code.

## Perform pca

### Subtask:
Scale the numerical data and perform PCA to reduce the dimensions to 2.

**Reasoning**:
Select numerical columns, scale the data, and perform PCA for dimensionality reduction as per the instructions.
"""

# 1. Select only the numerical columns from the df DataFrame.
numeric_cols = df.select_dtypes(include=np.number).columns
df_numeric = df[numeric_cols]

# 2. Instantiate a StandardScaler object.
scaler = StandardScaler()

# 3. Fit the scaler to the selected numerical data and transform it.
df_scaled = scaler.fit_transform(df_numeric)

# 4. Instantiate a PCA object with n_components=2.
pca = PCA(n_components=2)

# 5. Fit the PCA model to the scaled data and transform it.
X_reduced = pca.fit_transform(df_scaled)

# 6. Store the transformed data in a new variable, for example, X_reduced.
# X_reduced is already created in the previous step.

"""## Prepare pca data for plotting

### Subtask:
Create a pandas DataFrame with the reduced PCA data.

**Reasoning**:
Create a pandas DataFrame from the PCA reduced data and assign column names.
"""

df_reduced = pd.DataFrame(X_reduced, columns=["PC1", "PC2"])

"""## Define app layout

### Subtask:
Create the Dash app layout with two sub-divisions for the interactive scatter plot and the static PCA plot. Include dropdowns for selecting columns in the interactive scatter plot section.

**Reasoning**:
Create the Dash app instance and define the layout with two sub-divisions and the required components including dropdowns and graphs.
"""

app = Dash(__name__)

numeric_cols = df.select_dtypes(include=np.number).columns

# Create the PCA plot figure before defining the layout
fig_pca = px.scatter(df_reduced)

app.layout = html.Div([
    html.H1("Customer Data Analysis Dashboard"),
    html.Div([
        html.Div([
            html.H2("Interactive Scatter Plot"),
            html.Label("Select X-axis:"),
            dcc.Dropdown(
                id='x-axis-dropdown',
                options=[{'label': col, 'value': col} for col in numeric_cols],
                value=numeric_cols[0],
                clearable=False
            ),
            html.Br(),
            html.Label("Select Y-axis:"),
            dcc.Dropdown(
                id='y-axis-dropdown',
                options=[{'label': col, 'value': col} for col in numeric_cols],
                value=numeric_cols[1],
                clearable=False
            ),
            dcc.Graph(id='interactive-scatter-plot')
        ]),
        html.Div([
            html.H2("PCA Scatter Plot (2D)"),
            dcc.Graph(id='pca-scatter-plot', figure=fig_pca)
        ])
    ])
])

@app.callback(
    Output('interactive-scatter-plot', 'figure'),
    Input('x-axis-dropdown', 'value'),
    Input('y-axis-dropdown', 'value')
)
def update_scatter_plot(selected_xaxis_column, selected_yaxis_column):
    fig = px.scatter(df, x=selected_xaxis_column, y=selected_yaxis_column,
                     title=f'Scatter Plot of {selected_xaxis_column} vs {selected_yaxis_column}')
    return fig

if __name__ == '__main__':
    app.run(debug=True)

"""## Create static pca plot

### Subtask:
Generate the scatter plot for the PCA-reduced data.

**Reasoning**:
Generate a scatter plot for the PCA-reduced data using plotly express.
"""

fig_pca = px.scatter(df_reduced)

"""## Implement interactive scatter plot callback

### Subtask:
Create a callback function that updates the interactive scatter plot based on the column selection from the dropdowns.

**Reasoning**:
Create a callback function to update the interactive scatter plot based on the selected x and y columns from the dropdowns.
"""

@app.callback(
    Output('interactive-scatter-plot', 'figure'),
    Input('x-axis-dropdown', 'value'),
    Input('y-axis-dropdown', 'value')
)
def update_scatter_plot(selected_xaxis_column, selected_yaxis_column):
    fig = px.scatter(df, x=selected_xaxis_column, y=selected_yaxis_column,
                     title=f'Scatter Plot of {selected_xaxis_column} vs {selected_yaxis_column}')
    return fig

"""## Run the app

### Subtask:
Add the code to run the Dash app.

**Reasoning**:
Add the code to run the Dash app using the standard Python conditional and `app.run_server`.
"""

if __name__ == '__main__':
    app.run_server(debug=True)

"""**Reasoning**:
Fix the error by replacing `app.run_server` with `app.run` and include the static PCA plot in the layout.


"""

app = Dash(__name__)

numeric_cols = df.select_dtypes(include=np.number).columns

# Create the PCA plot figure before defining the layout
fig_pca = px.scatter(df_reduced)

app.layout = html.Div([
    html.H1("Customer Data Analysis Dashboard"),
    html.Div([
        html.Div([
            html.H2("Interactive Scatter Plot"),
            html.Label("Select X-axis:"),
            dcc.Dropdown(
                id='x-axis-dropdown',
                options=[{'label': col, 'value': col} for col in numeric_cols],
                value=numeric_cols[0],
                clearable=False
            ),
            html.Br(),
            html.Label("Select Y-axis:"),
            dcc.Dropdown(
                id='y-axis-dropdown',
                options=[{'label': col, 'value': col} for col in numeric_cols],
                value=numeric_cols[1],
                clearable=False
            ),
            dcc.Graph(id='interactive-scatter-plot')
        ], style={"flex": "1"}),
        html.Div([
            html.H2("PCA Scatter Plot (2D)"),
            dcc.Graph(id='pca-scatter-plot', figure=fig_pca)
        ], style={"flex": "1"})
    ], style={"display": "flex"})
])

@app.callback(
    Output('interactive-scatter-plot', 'figure'),
    Input('x-axis-dropdown', 'value'),
    Input('y-axis-dropdown', 'value')
)
def update_scatter_plot(selected_xaxis_column, selected_yaxis_column):
    fig = px.scatter(df, x=selected_xaxis_column, y=selected_yaxis_column,
                     title=f'Scatter Plot of {selected_xaxis_column} vs {selected_yaxis_column}')
    return fig

if __name__ == '__main__':
    app.run(debug=True)

"""## Summary:

### Q&A
* **Explain the error in the selected code:** The error encountered was an `ObsoleteAttributeException` when trying to run the Dash app using `app.run_server(debug=True)`. This exception indicates that the `run_server` method is obsolete and has been replaced by `app.run`.
* **Fix it if possible, and incorporate the changes into the existing code:** The error was fixed by replacing `app.run_server(debug=True)` with `app.run(debug=True)`. This corrected line was incorporated into the final code block which contains the complete Dash application.

### Data Analysis Key Findings
* Numerical columns were successfully identified and scaled using `StandardScaler`.
* PCA was applied to reduce the dimensionality of the scaled data to 2 components, stored in the `X_reduced` variable.
* The PCA-reduced data was successfully converted into a pandas DataFrame `df_reduced` with columns "PC1" and "PC2".
* A static scatter plot for the PCA-reduced data was generated using `plotly.express`, stored in `fig_pca`.
* A Dash app layout was created with two sections: one for an interactive scatter plot with dropdowns for selecting axes, and another for the static PCA plot.
* A callback function was successfully implemented to update the interactive scatter plot based on the dropdown selections.
* The Dash app was successfully run using `app.run(debug=True)`.

### Insights or Next Steps
* The dashboard successfully visualizes both the original data with interactive exploration and the PCA-reduced data.
* Consider adding more interactive features to the PCA plot, such as hover information or coloring points based on a categorical variable.

"""